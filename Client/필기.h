#pragma once
#include "pch.h"
#include "CEngine.h"


//bitmap 윈도우 영역은 모니터 해상도보다 작을 수 있다.
//메뉴,윈도우창 윈도우7시절 두께등 영역
//
// define \ 쓰면 다음 줄까지 포함하는 코드 
// 
// 
//윈도우 크기 설정
//resolution 해상도
//RECT  상하좌우 long 구조체
//LPRECT RECT포인터 타입 윈도우는 P는 포인터타입 반환 L은 옛날 잔재
// 
//AdjustWindowRect() -> RECT의 주소값에 다시 반환
//_Inout_ 포인터값 보통 주소값을 알려주면 거기다가 반환해준다
//SetWindowPos() 윈도우값 안씀 0,0, 왼쪽에서 오른쪽뺴기, 밑에서 위 빼기, 자료 0 크기변경
//ShowWindow() 메인윈도우값, true



//이중 버퍼링
// 
//버퍼2개써서 해상도 노출 
//윈도우창이 아닌 비트맵 생성을 해서 윈도우창에 복사해서 그림 출력
//커널오브젝트 핸들값
//비트맵 생성 함수 HBITMAP hbit = CreateCompatibleBitmap(); //호환성 체크 첫번째 HDC값 가로길이, 세로길이,
//윈도우는 핸들값을 넣어줘야 운영가능
//DC생성함수 CreateCompatibleDC() 메인 DC 넣어주면 두번째 DC생성가능
//생성한 DC에 비트맵을 넣는 함수SelectObject() HDC, BITmap  -> 원래 비트맵이 나오는데 디폴트 비트맵이 나오기때문에 지워줘야됌
//따로 만든 DC이기때문에 소멸자코드를 써줘야한다.
// DeleteDC()
// OeleteObject()
// 
// 랜더링을 전부 세컨드DC쪽에 해두고 
// 복사함수 BitBit() 목적지DC, (복사받을영역)0,0, 해상도x, 해상도y, 세컨드DC, 탑0,아래0, SRCCOPY복사옵션)
// 
// 
// 키입력 중 마우스 힐은 윈도우 메세지 기반으로 해야된다.
// 오브젝트를 더욱 부드럽게
// 
// 간격체크 DT의 초당 새는것으로 쿨타임을 만들 수 있음
//

// 갤러그 만들기
// 
// 몬스터가 자체적으로 움직임
// 플레이어가 미사일을 쏨 
// 한가지 이상의 다양한 패턴의 미사일 만들기

//6/28
//scene쪽 틱이 오브젝트 사이즈를 체크하기 때문에 문제가 안생긴다. 플레이어에 에드 오브젝트를 해놨기떄문에 문제 생길 수 있다.
//즉 문제가 생기는 이유는프레임은 한순간에 실행되는게 아니라 순차적으로 실행되기때문에 1프레임 단위로 동기화 과정이 필요하다
//오브젝트 포인터 타입으로 저장중
// Pen, Brush
//커널오브젝트 생성
//HOLLOW = 투명 브러쉬
//GetStockObject() -> 윈도우의 이미 만들어져있는 기본 커널오브젝트를 요청할 수 있는 함수 -> 내가 안만들어서 지우면 안됌 이미 생성된 오브젝트
//SelectObject(핸들값, 원하는값)
//생성자 소멸자를 이용해서 펜과 브러쉬를 생성자에 넣어놓고 빠져나온 이전값을 소멸값에 적어놔 되돌리는 코드를 작성하면 
//다음에 작업하기 편하다.
//최소한의 변수명이 없으면 컴파일러가 최적화하여 코드를 지워버린다.
//엔진 주석
//리소스 개념
//Resource
//메모리 상의 같은 종류의 리소스를 들어올 필요가 없음
//이미지, 사운드, 
//아직 만들지 않는 자료를 전방 선언으로 강제로 저장할 때 포인터타입을 저장하면 문제가 안생기는데 포인터가 아닐경우 구체적인 크기를 알 수 없어서 문제가 생길 수 있다.
//헤더쪽에 전방 선언을 하는 이유 최대한 헤더참조를 적게하여 컴파일러 속도를 올리기위해
//헤더참조를 하게 되면 다시 코드를 읽어야하기 때문에 컴파일러 속도가 낮아진다.
//헤더에서 전방선언을 하는 것은 
//cpp쪽에선 자신의 헤더파일 밑에 전방선언된 헤더쪽의 참조를 함으로써 이로인해 바뀐 자신의 코드를 컴파일러가 확인을 해야되는데
//자신의 헤더참조 밑에 함으로써 다시 자신의헤더파일을 확인하지않게 하기 위함
//이진트리구조는 탐색이 빠르기 때문에 리소스에서 쓰기 좋다. -> 리소스들을 계속 참조시켜야되기때문에 저장만 해서는 안된다.
//
//이미지 로딩
//h인스턴스 필요없음
//\\해야 \표시됌
//LoadImage() h인스턴스, 경로, 이미지_이미지, 픽셀수지만 0,0넣어주면 알아서 잡아줌, 로드옵션 (비트연산자로 옵션 연속으로 합칠 수 있음) -> 비트맵핸들값 반환
//Get에러 에러가 생겼을때 확인용 함수
//직접적으로 이미지를 객체마다 넣어주면 만들어질때마다 리소스가 메모리에 계속 만들어지기 때문에 비효율적

//6/29
//그래서 새로운 클래스를 만듬 
//BITMAP 구조체 비트맵의 정보를 저장함 -> 확인할 수 있음
//FAILED -> 0보다 작으면 반환타입이 트루  문제 상황 체크
//MessageBox(널포인트, 내용,제목, MB_OK) OK창
//경로문제 관리
//경로를 잡는 함수를 사용해 프로그램이 사용하는 폴더 기준으로 작성해주면 된다.
//sin는 프로젝트를 기억하는 것일 뿐이고 삭제한다고 헤더와 cpp는 사라지는것이 아니다
//솔루션탐색기 -> 프로젝트 -> 구성-> 일반 -> 출력디렉터리 경로를 바꿀 수 있다. 
//경로를 바꾼 이유 -> 실행파일에 리소스들을 넣기 위해
//경로폴더 접근 글자수 제한 255글자 + null
//wcslen_s() 크기 체크
//wcscat_s() 목적지, 뒤이어붙은 문자
//디버깅모드에선 비쥬얼스튜디오 기준에서 실행되기때문에 구성에서 바꿔줘야한다.
//구성 -> 디버깅 -> 작업디렉터리 -> 우리규칙에 맞는 폴더

//6/30
//문자열이라도 +해주면 문자가 더해짐
//절대경로 -> 모든 경로를 입력함
//상대경로 -> 컨텐츠상태로 존재하는 최종위치
//마스킹 -> 원치않는 부분을 가리는 용어
//색상마스킹 기능을 지원함
//TransparentBlt()  HDC, 좌상단 좌표, 우하단 좌표, 이미지 가로, 이미지 세로, 리소스HDC, 0,0, 이미지 가로길이, 이미지세로길이, 걸러낼 색상
//링크에러 2019 함수선언만 해놓고 다시 불러올때
//컴파일러가 이미 된 라이브러리 기능이라 transparentblt은 참조가 아직 안되어있어서 참조해야됌
//pragma coment(lib,"msing32.h")
//Collision
//컴포넌트 설계
//유니티 객체 만들때 생각하면 됌
//dynamic_cast<다운캐스팅된 클래스> 트루면 1 펄스면 널포인트
//상수값으로 초기화할 경우 초기화할 때의 값으로만 고정된다.
//부모쪽에서 기본생성자를 오버로딩할 경우 자식클래스는 내가 의도한 생성자를 강제할 수 있다.
//그러면 부모클래스에서 자식클래스의 타입을 알 수 있게 설계할 수 있다.
//부모쪽의 기능을 계속 쓰고 싶고 자식도 쓰고 싶다면 자식쪽 함수에 부모 함수를 호출해준다.
//

//7/1
//오버라이딩했다고 해서 부모쪽 함수를 재호출하는 것이 c++스타일이다
//부모클래스를 타입재정의(메크로)를 해서 내가 편한 클래스이름으로 정의할 수 있다.
//컴퍼넌트 설계
//컴퍼넌트 쪽에서 오브젝트를 모르기 때문에 자신을 알려야해서 오브젝트this를 알려야한다.
//Offset 기준점에서 얼마나 떨어져있는지 (프로그래밍쪽 해석) 기준점에서의 추가적인 차이값
//수정당하지 않게 오퍼레이터 리터값을 임시객체에 넣어준다.
//싱글톤 오류 걸린 이유 : 엔진에서 싱글톤을 참조하고 있었는데 엔진쪽을 먼저 참조하는 바람에 싱글톤을 인식 못함.
//한번에 오브젝트들을 넣어두면 수열대로 검사를 해야되는데 이를 해결하기 위해
//레이어 분류를 해두면 검사 횟수가 적어진다.
//그래서 scene안에 layer라는 개념을 구현해서 레이어 갯수를 임의로 정해서 설정한다. (우리 프로젝트는 16개)
//이넘클래스로 분류 기준 정하기
//DEFAULT 애매한 것들
//이넘은 = 오버로딩이 구현되어있어서 자기 순서를 임의로 정할 수 있다.
// 배열의 배열이기 때문에딜리트할때도 이중for문으로 지워줘야된다.
//

//7/4
//충돌관리는 매트리스표를 구현한다.
//충돌값만 관리하기때문에 비트로 판단한다.
//16개의 레이어를 설정했으니 2바이트 변수를 설정해놔서 16x16으로 표를 작성한다.
//WORD = unsigned short
//memset(); -> 배열의 시작주소, 초기화 값, sizeof()* 배열의 갯수 -함수 기능 적힌 배열을 전부 0으로 초기화
//row 행, col 렬 행 가로줄 렬 세로줄
//비트 연산을 통해 col만큼 밀어주면 원하는 값에 처리됨
// |비트합 &비트 둘다 트루면 트루
// 첫충돌인지 아닌지 검사
// 자기자신끼리 충돌검사, collider충돌체 component 소유 검사
// &레퍼런스 참조형태로 원본형태로 돌려주면 복사값이 줄어든다.
// const 변수 & 주면 원본을 수정을 못한다.
// 수정을 가능하게한 함수를 구현해도 함수를 호출하면 오류가 뜬다.
// void a () const {} 변수값 상수 보호를 받는 상태에서 호출가능하게 한다. 오버로딩에 이용되기도 한다. -> 변수값을 확인하는 용도인 함수는 const를 붙여놓으면 받는 변수가 const &였으면 함수 호출이 가능하다.
// 강제 규칙 이 함수는 본인멤보 수정불가 
// const 참조
// const로 구현할려고하면 헤더쪽에서도 cpp쪽에서도 const를 붙여야한다.
// 
// move construct rvo nrvo 이동 생성자 -> 알아두면은 좋다.
// fabs() 절대값 x축 겹쳐있을때 절대값을 구하고 원래 두 콜리더의 x축 반씩을 더하것을 비교하고 똑같이 y도 비교하면 충돌값이 트루인지 펄스인지 알 수 있다. true false 
//

//7/5
//충돌이 발생한 시점과 벗어나는 시점
//그 시점을 알 수 있는 충돌 중인 경우
//충돌 설계 방식이 나뉨
//유니티		: 부딪히는 순간, 겹쳐있는 순간, 벗어나는 순간 () -> 쓰기편함
//얼리얼엔진	: 충돌 진입과 해제 (비긴,엔드 오버랩) -> 겹쳐있는 순간 호출값이 비효율적이라고 생각해서 충돌(비긴)했을때 bool변수를 추가해서 트루 엔드 오버랩 함수가 호출됐을 때 false ->극한의 최적화
//인자, 상대방 콜라이더 -> 오브젝트 안에서 구현되어있기때문
//static 정적변수는 데이터 영역에 있기때문에 ++ 연산자를 해두면 만들어질때마다 ++된다. 
//static은 이니셜라이즈가 아닌 전역영역에서 초기화한다.
//**엔티티 순수가상함수 구현 안되어있음
// const iD 를 만들어서 고유의 아이디를 만들어서 오브젝트 관리를 한다. 하지만
// 문제점 const는 이니셜라이즈로만 초기화할 수 있는데 복수생성자는 이니셜라이즈로 복사하기 때문에 복사가 된다.
// 디폴트 복사생성자가 문제가 된다. 포인트로 복사가 되니 내가 직접 구현하여 복사값에 const 값을 넣어준다.
// 깊은 복사 -> 내가 직접 해주지 않으면 오류가 발생
// 얖은 복사 -> 그냥 복사
// 문자열 비교는 문자열을 전부 비교해야되서 느리다.
// 기본 대입 연산자는 컴파일러가 함수 자체를 삭제해버린다.
// 
// 유니온 union (공용체)
// 자료형 취급
// 가장 큰 자료형을 따라감
// 메모리는 똑같은데 같은 메모리 상에 세부 방을 나눌 수 있음
// 왼쪽방 오른쪽방에 id를 넣어줘서 하나의 8바이트타입 id를 만들어준다.
// 
// 충돌체를 껐다 켰다 함으로써 지속적인 데미지를 구현할 수 있다.
// 
// if 문이 끝나면 지역변수는 소멸자가 호출된다.
//
// 
 
 
//7/6
//
//이중 for문에서 i를 +1로 잡아주면 자기 자신을 검사를 안하기 때문에 오류 발생을 막아줄 수 있다.
//
//디버깅모드에서 동적할당한 메모리를 잘 해제가 되었는지 확인할 수 있다.
//include <crtdge.h> crt라이브러리 헤더 -> 인터넷 검색
//vector2는 vec2 이름으로 메크로 처리했고 struct헤더 파일에 구현되어있다.
//카메라를 구현할때에는 카메라 위치는 거의 고정되어있고 다른 랜더링의 물체가 빼준 값이 나온다
// UI는 계산된 후 랜더좌표를 굳이 받아올 필요가 없다. 즉 본인의 실제 좌표를 그리면 된다. 
//
//

// 7/7
// 카메라 과제 -> 카메라 진동효과 만들기
// 함수 호출 
// 포커싱하는 지점은 따로 지정해야되고 흔들리는 변화량은 따로 계산해줘야한다.
// look값을 건들지말고 따로 함수를 구현해보자
// 
// 카메라 랜더링
// transparent 투명화 특정 rgb 제외
// 
// RGBA Alpha 는 투명도이다. 0~255 0으로 갈수록 투명해짐
// Alpha Blend    
// Blend 섞는다 색상을 합치는 작업
// 포토샵 이미지 레이어 옆에 있는 채널 마스크영역 컨트롤 시프트 i 영역반전
// 
// transparent 인자가 똑같은데 마지막에 BLENDFUNCTION 이라는 구조체값을 요구 
// 구조체 안의 값을 채워서 넣어줘야 됨 -> 검색해서 넣어두면 됌
// sourceconstantalpha에 변수를 채워넣으면 조정이 가능하다
// 화면 출력도 일렬메모리 구조이기때문에 밑에서부터 저장한다. 
// 24비트로 이미지로 출력을 하면 2진수로 딱 안맞기 때문에 페딩이라는 메모리 줄바꿈이 생기면서 연산이 늘어난다.
// 32비트로 이미지로 출력을 하면 2진수로 출력하기때문에 연산이 빨라져서 프레임이 확보가 된다.
// 소스알파는 자기 알파를 써라라는 의미이기 때문에 완전블랙으로하면 0,0,0이기 때문에 적용이 안된다.
// 알파블랜드로 카메라 시야효과
//
//
// 7/8
// 실수 계산했을 때 Duration이 0.5를 초과해버리고 그 값을 빼버리니 음수가 되버리면서 페이드 인 할때 음수값이 들어가면서 완전 반전값이 나와버린다.
// 그래서 1을 살짝이라도 초과해버리면 다시 1로 지정해버리는 조건을 달아둔다
// 카메라 페이드 인 아웃 효과를
// tick을 거치지 않고 순차적 진행 
// 구조체 생성 -> 자료구조에 넣기 -> 그대로 설계
// 리스트 안에 프런트 호출 다 실행하면 프런트 삭제 이 과정을 조건문 프런트가 비어있지않다면.
// 연산해도 효과가 없는 것들은 연산을 조건을 걸어버리면 최적화를 할 수 있다.
// 카메라를 알파값을 건드려서 낮밤을 건드릴 수 있다.
// 삭제를 바로 해버리면 벡터로 관리하고 있기 때문에 먼저 생성된 것은 뒤쪽 객체를 삭제된줄도 모른다
// 그러면 없는 객체를 참조를 하기 때문에 문제가 생긴다.
// 삭제과정은 프레임 과정으로 삭제예정선언 삭제예정확정 삭제순으로 해야된다.
// unsigned __int64 는 8바이트 자료형이다. 포인터랑 호환가능하다. == DWRD_PTR 호환 가능한 포인터
// 
// cur선언 부딪히면 숫자올라감 일정 수치 이상이면 몬스터 삭제
// 원상태를 돌면서 몬스터 지나감
// 완전 삭제를 제외한 충돌
// 스코어보드, 배경이동, 카메라이동, 미사일 일정시간 이동
// 

// 7/11 과제 : 데미지 기능 추가하고 재제출
// event, -> 데드 상태로 만들고 데드면 죽음  벡터순환
// scene
// if(dynamic_castM<CMissile*>오브젝트변수->getowner()) -> 다운캐스팅
// 충돌중이다가 사라지더라도 수정
// 
// 콜라이더 cpp
// 
// 콜라이더 h
// ID정리 맵정리 존재하지않는 ID삭제
// bool값이 flase면 삭제되는 방향
// 스테이지가 바뀔때 삭제되는 방향
// 
// 씬에서 cpp 충돌체크 및 클리어체크
// 
// 
// 애니메이션 기능
// 오브젝트가 애니메이터 컨포넌트를 가지고 있으면 다수의 애니메이션을 관리
// map구조로 다이렉트로 가리킬수 있는 애니메이션 변수
// 애니메이션은 컨포넌트가 아니니 엔티티를 상속
// 
// 7/12
// 애니메이터 헤더
// 오브젝트 렌더 구조개선
// 애니메이션 틱
// 동적할당된 곳을 지워야함
// 템플릿은 자료구조 만들때 앞에 템플릿을 붙여줘야하고 const &를 받아오면 이터레이터도 const버젼을 선언해줘야한다. -> 그래서 begin도 const 용 cbegin도 해야한다.
// 애니메이션 키체크로 할경우 버그
// 동시에 누르면 마지막 탭으로 한 애니메이션 재생 -> 상태값 체크
// 이너값 def 컴포넌트 순서 바꿈
// 충돌체나 애니메이션은 객체의 발기준으로 출력해주는게 좋다. 횡스크롤, 탑뷰형식 게임
// render하기전에 오프셋 더한 값 출력
// 플레이어 랜더 제거 -> 이유 애니메이터 컴퍼넌트 쪽에서 렌더 담당
// 이미지 픽셀이 제각각이면 소프라이트, 애니메이션툴을 가지고 편집
// 다리를 중심으로 애니메이션을 맞춰야 자연스럽다. 
// 
// 7/13
// 특정오브젝트들 생성 이벤트관련 함수는 전역함수로 구비해두는 것이 좋다.
// func.h 헤더파일
// 템플릿 함수<T>
// 이벤트 이넘 스트럭트 스트럭트 헤더와 pch 헤더로 옮김
// 14분
// 템플릿이 아닐경우는 cpp
// 리턴값을 주면 설정가능
// 1 라디안은 반지름이랑 호의 길이가 일치하는 순간이다
// 백터로 단순하게 계산하면 40프로만큼 이동한다. 1, 1 루트2
// 각도가 세타 
// cos세타 빗변 분의 밑변 = 비율값
// sin세타 빗변 분의 높이 = 비율값
// 
// 벡터 
// sqrt 루트
// vec2 노말라이즈 
// 
// 7/14
// 합차공식 
// 어소트락 공식정리 자료있음
// angle 각도
// radian 원주율
// degree 60분법 360도
// 
// 유효성체크 func-> isValid 널포인트인지 아닌지 데드인지 아닌지
// vec2 오버로딩 -> 좀 많이 했음
// 몬스터의 포지션과 내포지션을 빼면 무조건 몬스터를 향하는 방향으로 가는 미사일이 나온다
// 
// 두방향벡터사이의 각도를 구하는 상황
// 내적 Dot		->  값을 구해버리면 벡터가 아니라 스칼라 값이 나와버린다. x * x' + y * y' = 각벡터의 길이 곱하기 길이 곱하기 cos 세타 즉 내적값을 알면acos 으로 역으로 세타값을 구할 수있다.
// 외적 Cross	->  3차원 내적을 할때 순서에 따라 z축의 방향이 양의 값이냐 음의 값이냐 가 나옴
// 
// Scalar 순수한 정수 힘의 방향
// vertor 크기값 
//
// 즉 내적값을 알면acos 으로 역으로 세타값을 구할 수있다. 내적값을 넣어주면 구할 수 있다.
// 
// 7/15
// 내적했을때 두 백터의 길이중 하나의 벡터를 정규화 시켜서 내적시킬때 수직의 길이를 알아낼수있다. 투영시키다
// 진행하는 방향 -> 향하는 방향 순으로 감싸쥔다.
// 외적은 두벡터의 평행사변형넓이가 나온다
// 3d일때 평행사변형을 반으로 나누면 삼각형넓이가 나오기때문에 삼각형의 넓이와 외적으로 구한 평행사변형/2 의 넓이와 비교하여 히트판정을 낼수 있다.
// 
// 미사일 이미지 편집 및 미사일 방향에 따른 인덱스 계산
// acos (아크코사인) 양의 값만 나옴 0에서 180도의 값만 나옴 음수쪽에 속에 있어도 그쪽기준으로 180도 계산
// 이미지가 0~7까지 있는데 4등분해서 나온 플로어값을 대입할때 7에서 0으로 가야되는데 초과해버려서 8로 가버린다. 
// 그래서 이미지가 잘못 출력되는 오류가 뜬다.
// 
// 펑터지는 애니메이션
// Effect 오브젝트 상속받아서 효과가 나올떄마다 한번 생성시키고 삭제
// 
// component 
// Rigidbody 강체
// 힘 = 질량 * 가속도
// F = M * A
// def.h -> 중력을 지우고 Rigidbody 가 중력을 역활을 한다.
// velocity 속도도 방향개념이 있다.
// 벡터끼리 곱하는 오퍼레이터 구현
// 
// 숫자를 0으로 나눠버리면 무한의 쪼개짐이 발생하기 때문에 infinity라는 의미로 nan값이 들어간다. 그러면 모든 연산이 다 틀어진다.
// 
// 계속 force에 힘이 계속 더해진다. 누적되고 있으니 매 tick 마다 force를 초기화해야한다.
// 
// 7/18
// 마찰력
// struct.h 벡터 isZero,- 오퍼레이터 추가 
// 마찰력을 적용시킬때 공기저항일지 순수히 땅위에서 미끄러지냐에 따라 다르다
// 힘이 제로인지 확인 -> 이걸 뺴면 반대방향으로 키를 움직이면 마찰력 + 힘이 들어가짐
// 제로라면 가는 길이의 마찰력만큼 뺀다. 
// 뺀 만큼이 0이 넘어가면 0으로 설정
// 
// 최대정지마찰력 -> 너무 현실적이라 현실적인 게임을 구현할려면 구현해라.
// 
// 마찰력에 질량값을 곱해버리면 중력개념이 구현됌
// 키매니져에서 마우스 입력 체크
// GetcursorPos 마우스 위치
// ScreenToClient 특정 클라이언트에 좌표 계산해줌
// 
// Scene_Logo tick 오버라이딩 
// 
// 카메라 실제포지션 반환 차이값을 더한 값을 반환해야 실제좌표랑 랜더링 좌표랑 차이나기때문에 해줘야한다.
// 콜라이더에 충돌타입도 구현 
// 원형타입끼리 충돌할때 구현이 쉬움
// 반발력 구현 진행하는 속도에 맞춰서 팅겨나는 방향 계산 입사각 반사각 직각으로 계산
// 탑뷰형식일때 충돌 로직을 원으로하면 편함
// 충돌 case 이론을 구현해봐야한다.
// 
// 툴제작
// 미사일 이슈 라디안 -> 60분법
// 윈도우 포커싱안할때 키관련 이벤트 먹통되게하기
// none으로 때려버리는게아니라
// 마우스 상태에 따라 상태값을 바꿔야한다.
// 탭 프레스는 릴리즈ㅡ
// 릴리즈는 논으로 
// 
// 60프레임을 초과할 경우 강제 방어
// 타임매니저 DT가 디버그일때 팍 튀는 현상을 60분의 1초를 넘어선다면 60분의 1초로 계속 고정시켜두는 조건을 걸어두면 튀는것이 없어진다.
// 
// 7/19 ** 얕은 복사, 깊은 복사에 대한 개념인데 포인터만 문제가 생기는게 아니라 카운트같은 고유의 변수가 들고 있다면 0으로 초기화 해야될 필요가 있다.
// 
// object clone() -> 자기자신을 복사해서 새롭게 동적할당하기 때문  
// 디폴트 복사생성자 문제. 컴포넌트가 같은 포인터를 가리키는 문제가 생김 컴포넌트는 소유오너를 세팅해놨기때문에 알림도 가지 않음
// -> 오브젝트의 복사생성자를 해두면 컴포넌트 복사생성자의 문제. -> 컴포넌트도 clone을 구현해두면 자기자신의 컴포넌트를 복사하면 오브젝트 복사생성자구현할때 편함
// def.h에 재정의로 반복되는 구문, clone을 정의. 복사생성자를 직접구현할때는 부모의 생성자를 명시적으로 적어줘야된다. 안적어주면 부모쪽 생성자는 복사생성자가 아니라 기본생성자로 초기화되버려서
// 문제가 생겨난다.
// 컴포넌트 오너는 다시 새롭게 추가되는 컴포넌트 함수에서 자기자신으로 덮어버리기때문에 기본복사생성자로 충분하다.
// animator의 복사생성자 구현. 컴포넌트와 비슷한 문제 람다표현식(이터레이터 순회의 다른 방식)
// animation 굳이 clone을 구현할 필요없다. animator포인터가 문제가 생길 수 있지만 다시 this로 덮을거기때문에 딱히 문제가 없다.
// ccollider -> 카운트때문에 복사생성자를 구현해야됌   
// 진열장처럼 만들어놓고 원할때 clone함수를 호출해서 씬에 배치시키는 느낌 -> proto type pettern 속도가 빠르다.
// proto type pettern	런타임중 성능 확보(이미지 생성 로딩 값 없음. 로딩 지연시간 줄임)
//					  
// Tool
// 오브젝트 복사구조가 탄탄하게 잡혀있어야지 오류가 안 생긴다.
// sceneMgr 에서 Scene생성
// func.h 이벤트 관련 함수 생성 씬체인지
// scene을 바꿔달라는 함수가 실행되면 모든 프레임이 종료되고 scene이 변경되게 구조잡기
// 이벤트매니저 구조 변경
// 
// 7/20
// scenemgr 씬을 바꾸는 함수 구현 -> init도 바꿈 scene change
// Scene의 init을 enter로 바꾸고 함수 명에 걸맞는 함수 구현
// Cscene 오브젝트 딜리트 함수 
// 소멸자에서의 vector속 내용물을 삭제할때에 소멸자가 벡터내에서도 소멸자가 호출되기때문에 상관없지만
// 다른 곳에서 삭제함수를 호출할땐 벡터가 삭제한 곳을 가리키고 있기 때문에 비워줘야한다.
// exit 오브젝트삭제 콜리젼 상태값 클리어
// 
// tile 이미지를 쓸때 이미지가 픽셀이 맞아야 편함
// tile이 모여있는 이미지를 타일아틀라스라고 한다.
// tile class 추가
// tile 사이즈를 미리 정해두면 좋다. ex 16 32 64
// tile은 rendering할때 좌상단 기준이다.
// TransparentBlt은 특정값을 배제하고 출력하는 함수이다.
// 이미지 인덱스를 이미지 타일 갯수만큼 입력하고 행 ㅡ 렬 ㅣ 일때 행만큼 나누고 나머지 값을 하면 나눈 값이 행이고 나머지 값이 렬이다. 이걸 이용해서 이미지를 찾으면 된다.
// 
// object 설치 기능
// bitmap쓸때 32비트 써야됨 프레임 방어
// 
// TOOL
// window에서 제공하는 ui를 활용해 제작
// 메세지 WM_COMAND(메뉴를 클릭했을때 호출)입력과  wParam(메세지가 호출됐을때 무엇이 눌렸는지) 인자에 들어있는   
// IDM_ABOUT ->
// 
// resouse.h에 들어있음
// 
// DialogBox 메인윈도우와 다른 윈도우   //About 함수포인터
// 윈도우를 쉽게 생성할 수 있다. 
// 리소스 뷰에서 아이어로그 -> 아이디값을 넣어주면 미리 생성된 디자인을 노출시킨다. 
// F4 속성 띄우기
// 보기 -> 도구상자 -> 탭밑에 추가 -> edit control -> 
// 메뉴도 커널오브젝트이다
// TOOL에 메뉴 추가. 리소스뷰에 디자인데이터 추가 -> 리소스뷰?
// 메인윈도우에 붙여주기
// TOOL에서 나갈때 메뉴때기
// 메뉴셋에서 0를 넣어버려서 포인터가 가리키지 않게
// 엔진쪽에서 미리 생성하고 삭제  -> deletemenu 딜리트메뉴는 메뉴 속 탭 날리기 , destorymenu 메뉴자체를 없앨땐 디스토리이메뉴
// 메뉴를 추가할떄 윈도우 크기계산을 안했기때문에 다시 설정해야한다.
// 
// 7/21
// CALLBACK ABOUT은 window 정보창 처리함수 윈도우가 구현해놓은 함수
// IDOK IDCANCEL 디폴트값이 들어있는 코드 
// WndProc 메세지 처리함수 속 안에 WM_COMAND는 ID_값에 관한 처리 메세지
// ABOUT을 복사하여 전역함수로 내가 새로 지정하여 그쪽으로 처리하게 만들기 TOOL cpp에서
// wParam의 return 값을 ID값을 준다.
// 클릭도 메세지박스에 들어온다
// 하나의 씬안에서 모드변경
// 행렬 값을 구하여 타일에 무슨 타일인지 알아온다. 
// 하지만 툴씬에서 타일 선택할때 행렬값을 초과한 값을 클릭한 경우 음수인 경우 첫번째 행렬만 잡혀버린다.
// 타일 행렬값 반환 이미지값 증가 함수
// 
// 설정한 타일 저장 불러오기
// 저장 불러오기 메뉴바는 메인함수쪽에 있어서 함수를 호출하는 식으로 구현
// pch.h에 헤더 추가
// TOOL에 저장함수 구조체 구현
// File 형식 구조체 중 하나가 경로를 볼 수 있게 조건을 걸어 둘 수 있음.
// 
// 파일 입출력 구현해야함
// 확장자는 압축방식을 설명해둔 것뿐이다.
// 
// 이중포인터 포인터변수에 접근하기 위한 역활
// 쓰기모드 wb 이진트리바이너리 덮어쓰기
// File 구조체는 커널오브젝트이다 하지만 핸들값이 반환안되고 그 정보들이 들어 있는 주소를 반환해준다. 
// 메모리와 하드디스크의 연결 통로이다.
// 파일을 오픈하는 구조체를 생성했으면 파일을 fclose()를 써서 통로를 닫아줘야한다.
// 
// 7/22
// wb 쓰기모드 write binery 
// w모드로 스트림할때 27번이 들어올때 끊길 수 있다.
// 
// rb 읽기모드 read binery
// 
// void 포인트는 일단 주소만 받아올 수 있다.
// tool scene 저장 불러오기 구현
// 
// Tile에서 자기가 저장할 내용인 save , load 구현
// Tile을 enum값으로 타일의 종류를 나눠서 구현하기
// 이미지가 중간에 타일마다 다르게 배정될지라도 문제가 없게 세팅
// 
// 리소스매니져에 키값과 경로를 설정해놨는데 그것을 저장하고 다시 로드 한다. 
// 
// save 문제
// func.cpp
// 저장할려는 포인터가 nullptr일때 -> SaveImageRef(), LoadImageRef() 함수
// 
// 
// *****문자열 저장 방법 wstring 은 힙메모리에 있기 때문에 저장해버리면 없는 힙메모리 쪽에 주소를 접근하기 때문에 오류가 나버린다.
// - func함수에 save,load wstring 함수 구현
// *****c_str 포인터 주소 반환 -> const 타입이라 자기가 관리하고 있는 곳에 저장이 안된다. -> 이유 각 헤더에 구현되어있는 멤버들이 헤쳐지기때문에 정상적으로 작동하지않는다.
// 
// 메모리 과정을 생각하고 설계를 봐야한다.
// 
// 게임 UI user interface  설계구조 UI(큰틀) 속 UI(부속부품) 트리구조로 설계 하지만 자식들은 무수히많이 표현될 수 있기때문에 vector로 관리
// 
// 계층구조
// 부모포인터 = 최상위는 nullptr
// 자식포인터 -> vector
// 
// 반응형 함수
// 마우스가 위로 올라왔을때 
// 
// 7/26
// Scene에 UI추가
// CUIMgr 추가
// CUI만지기
// CButten 만들기
// CPanel 만들기
// 
// object포인터로 가져온 object들은 자기 자신을 모르니깐 다운캐스팅을 해줘야한다
// keymgr에 마우스 좌표가지고있음
// BtnDown은 누르자마자 반응
// BtnClick은 누르고 떼야 반응 
// 
// 부모offset과 자식offset을 더하면 자식의 offset을 구할 수 있음
// 
// 부모의 UI가 자식UI의 tick 과 render를 호출하기 때문에 addobject는 최상위 부모만 넣어주면 된다.
// 부모가 자식을 호출되는 구조되기때문에 자식 UI가 올라가면 우선순위가 자식쪽으로 간다. -> 레벨순회를 해서 
// ->하지만 UI는 지워지는 것은 최상위부모이기 때문에 자식 UI는 UI쪽에서 소멸자를 호출해줘야한다.
// 
// 자식UI는 부모의 상대좌표이기때문에 부모 내부에 자신의 좌표를 설정해야한다.
// 
// UI를 상속받을때는 자식쪽 tick을 실행하고 무조건 부모쪽 tick을 반드시 호출해줘야한다
// 
// 
// 7/28
// L버튼을 재정의 할 경우 부모쪽 한번더 호출해줘야한다.
// panelUI tick
// scenetool
// main
// Cui
// button
// 
// 현재 마우스와 클릭했을때 마우스 값을 구하고 빼면 드래그 하는 느낌 날 수 있게 할 수 있다
// 함수포인터 자료형처럼 재정의
// tool에서 함수포인터 생성 
// 객체와 함수를 묻어서 준다 델리게이트 
// 단순하게 호출시킬 함수를 전달시킨다 -> Callback 메서드를 전달한다.
// 함수포인터에선 &를 붙여줘야한다.
// 멤버함수포인터에선 무조건 &를 붙여줘야한다.
// 
// 
// 델리게이트
// 객체도 알려주고 함수포인터도 알려준다.
// 멤버함수포인터를 줄려면 정확하게 다 입력해줘야한다. 함수와 반환타입 인자
// 부모타입 포인터로 가리킬 수 있다. 그래서 부모타입으로 모든 클래스의 함수를 다 호출할 수 있다.
// 
// 7/29
// pPenel 재정의
// CUI render수정
// button render 수정
// 
// CUI는 최상위 부모이지만 clone함수를 구현해줘야한다
// 부모쪽에서 포인터 인자부분에서 인자에서 포인터자기자신으로 관리하기 때문
// 그래서 복사생성자할떄 깊은 복사를 해줘야한다.
// 깊은 복사해줬을때 부모쪽 복사생성자를 넣어줘야한다. 안넣어주면 기본생성자가 실행된다.
// CUimgr 지역변수말고 맴버변수로 변경 후 타겟UI 이벤트 순회 수정
// tick
//  
// CUI 최상위부모찾기 함수 구현
// scene 수정 
// toolscene에  CUIMgr 
// clear함수 추가
// 7시 13분  ui응용법
// 이미지크기를 계산 x길이랑 이미지 갯수랑 뺸다음 나누면 된다
// 
// 타일랜더링 최적화 화면 안에 들어온 애들만 랜더링
// 
// 8/1
// 타일 최적화 필요한 부분만 랜더링 결국 모든 타일을 순회하기 때문에 효율이 안좋음
// j가 행 i렬
// 수식을 세워서 필요한 부분만 랜더링만 하는 경우로 바꿈
// 
// rigidbody에 최대속도 생성 및 제한
// 속도 제한 조건 설정 붙여서 가속도를 많이 붙여버리면 관성을 신경안써도 되어 조작감이
// 나쁘지 않다.
// 중력 설정 tick
// -= vec2 오퍼레이터 만듬
// * 오퍼레이터
// 중력도 maxspeed가 적용되어 빠르게 떨어지지가 않음
// 내적Dot 을 하면 밑변의 길이를 알 수 있음 ->
// 땅을 만듬
// 게임에서 점프를 만들려면 고정속도를 설정해두면 쉽다
// 아니면은 점점더 속도를 증가하는 물리적 상황을 구현해야된다.
// F = m x A상승
// AddVelocity 원래 속도에 더해주고
// SetVelocity는 강제로 속도를 세팅
// 땅 충돌체 만듬 플레이어랑 계산 로고에서
// 
// 점프가 안된 이유 강체가 계산되기 전에 충돌체가 먼저 계산되서 계산이 꼬였다.-> 순서바꿔줌
// 충돌체 계산 할때 1픽셀 더 올려줌
// AddVelocity라 점프했을때 기존의 속도에서 튀어오른다. 혹은 상쇄된다.
// setVelocity를 하고 그 셋만큼 기존의 속도에 더해주면(x축은 남기고 y축만) 매끄러운 점프가 된다. 
// 
// 8/2
// 계획 세우기) notion  일정 계획표 진행상황 작성후 링크 올리기 -> 4주간 포폴 만들기 웹에서 공유 체크하고 댓글 허용 한 채로 보내기
// 
// 
// pch.h는 최상위 헤더 이기때문에 수정이 항상 일어나는 헤더들은 다른 곳으로 옮기는 곳이 좋다 -> 변경될때마다 빌드시 느려짐
// 유니티 빌드란? 
// 빌드 속도란 cpp는 obj파일로 컴파일러로 읽는 과정
// 즉 cpp의 코드들을 한 cpp로 넣으면 빌드 속도가 올라간다. 하지만 작업이 불편하기 때문에 나눠서 작업한다.
// 
// 그래서 비쥬얼스튜디오에서 만든 유니티 빌드 시스템
// 
// 클라이언트 -> 속성(모든 구성) -> 고급 ->  unity빌드 사용 예-> c++ ->unity 빌드 -> 최대소스수 20개 -> 파일 디렉터리 (해당 경로 설정) 
// 
// defauit -> pch.cpp(만들기) -> include"pch.h" -> client -> 속성 (ProjectDir) -> 모든 구성 ) 미리 컴파일러된 헤더 (사용) -> pch.cpp를 우클릭 속성 ->
// pch.cpp) 미리컴파일러된 헤더 (만들기)
// 
//	계획표 작성			1주 -> 툴제작
//						2주 -> player와 monster 구현 상호작용 (이펙트, 등등) 플레이어 기술 등 많은것 
//						3주 -> monsterAI, Boss 구현  
//						4주 -> sound / UI 개발 Hp, 인터페이스
// 
//  포폴 기간 4주		매주 월요일 참석 (주총결산) -> 15일은 휴일 이라 16일에 수업 
//						수업을 진행한다고 공지한 날
//						17일에 A-Star길찾기 알고리즘 수업
//						포폴기간에는 온라인, 오프라인 수업 병행
// 
// 8/3 
// (F모드 사운드) -> 상용사운드엔진 거의 모든 엔진들이 이 엔진을 쓰기때문에 쓰는 방법만 익히면 된다.
// Sound 확장자 wav(웨이브)만 재생됌
// ResouseMgr 에서 사운드 로드
// Play(bool) bool = 루프인지 아닌지 효과음
// PlayToBgm 백그라운드뮤직 -> 기존의 재생되고 있던 음악(배경음악)을 끄고 다시 시작
// 
// resouse 상속 매니져에서 관리
// soundMgr 윈도우에서 제공해주는 기능을 mgr에 넣어둠
// 
// stop 음악을 다시 진행할때 멈춘 부분에서 할지 처음부터할지 결정
// play할때 포지션이 리셋됌 -> setposition수정
// 
// setposition이 플레이하는 기능이 추가되어 바로 이 함수를 쓰면 재생됌
// 
// 리소스매니저에 딜리트 함수 
// 사운드매니저가 먼저 초기화하고 리소스매니저가 초기화해야한다.
// 
// 압축알고리즘이 따라 압축이 되고 재생될때 푼다.
// 인코딩							디코딩
// 
// AI
// Component AI 추가 enum class def.h
// Object 컴포넌트 가리키는 객체 함수 추가
// state 추가 -> Entity 상속 -> 상태들 추가
// 
// 몬스터 
// state Idle(기본), trace(객체 추적), Attack(공격) -> 모든곳에서 진입가능함ㄴ Dead상태
// -> 상속받은 몬스터(비행) state state Idle(기본), Trace_Fly(객체 추적), Attack(공격)
// -> 상속받은 몬스터(보스) state Idle(기본), trace(객체 추적)- Trace_Teleport, Attack(공격)-Attack1(공격)-Attack2(공격)
// 
// monster 구조체 추가 struct.h
// 파일 입출력으로 세팅하는 구조로 만들면 코드를 다시 칠필요가 없다 -> 안하면 바꿀때마다 재빌드를 해야됌
//
// vector2를 뺐을때 왜 길이값이 나오는지 공부 
// 플레이어포즈 에서 몬스터 포즈를 빼면 방향길이값 나옴
// 
// 7시 40분 디버깅 주소추적
// 메모리 컨트롤 알트 m 1
// 
// 몬스터 rigidbody가 pos값을 바꿈
// 포즈 버그터진 이유
// rigidbody 에서 세팅을 안했음
// 제로벡터를 노말라이즈를 하다가 포즈가 터짐 노말라이즈 예외처리
// 중력 예외처리 제로가 아닐때만 중력 제한
// 
// 8/4
// 카메라 포즈를 구해서 나누면 카메라에 영향받는 위치를 구할 수 있고
// 영향을 받지 않는 물체들은 굳이 이렇게 할 필요가 없다. -> 대표적으로 UI
// 애니메이션 카메라 변환 할것인지 안할것인지 인자가 있다
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 


















